""" channel_simulator.py

Runs link simulators given channel responses using Sionna.

"""

import tensorflow as tf
import numpy as np
from sionna.channel import cir_to_ofdm_channel, subcarrier_frequencies, ApplyOFDMChannel #, CIRDataset, OFDMChannel
from sionna.nr import PUSCHConfig, PUSCHTransmitter, PUSCHReceiver
from sionna.utils import compute_bler, compute_ber, ebnodb2no


class ChannelSimulator(tf.keras.Model):
    """ Simulate multi-user PUSCH/PDSCH transmissions over channels generated by ray
    tracing.

    This is achieved by frequency domain OFDM BER simulations.

    A key assumption is that the mobile can connect to multiple basestations simulataneously.

    Parameters
    ----------
    num_tx: int
        Number of transmitters in the scene.

    num_rx: int
        Number of receivers in the scene.
    
    a: [batch_size, num_rx, num_rx_ant, num_tx, num_tx_ant, max_num_paths, num_time_steps], tf.complex
        Path coefficients.
    
    tau: [batch_size, num_rx, num_tx, max_num_paths], tf.float
        Path delays.

    sinr: [num_rx, num_tx] flattened, tf.float
        The SINR values at the receiver locations corresponding to each transmitter.

    subcarrier_spacing: int
        How the bandwidth is divided into OFDM subcarriers. Must match that used to generated the CIR.

    fft_size: int
        Size of the FFT. Must match that used to generated the CIR.

    Inputs
    ------
    block_size: int
        Number of simulataneously simulated slots

    batches: int
        The number of blocks to simulate.

    ebno_db: float
        Signal to noise ratio used to calculate the noise variance

    Output
    ------
    ber: [num_rx, 1], tf.float64
        The bit error rate performance from each receiver listening to both transmitters. Multi-link operation.

    """
    def __init__(self, num_tx, num_rx, subcarrier_spacing, fft_size):
        super().__init__()

        # Instantiating key attributes
        self.frequencies = subcarrier_frequencies(fft_size, subcarrier_spacing)
        self.num_tx = num_tx
        self.num_rx = num_rx

        # Initialising the PUSCH components (there is PUSCH and PDSCH symmetry):
        self.pusch_config = PUSCHConfig() # Init pusch_transmitter with default settings 
        self.pusch_config.carrier.n_size_grid = int(fft_size / 12) # 12 subcarriers in a RB in 5G NR
        self.pusch_config.carrier.subcarrier_spacing = int(subcarrier_spacing / 1000)
        self.channel = ApplyOFDMChannel(add_awgn=True)
        self.pusch_transmitter = PUSCHTransmitter(self.pusch_config) 
        self.pusch_receiver = PUSCHReceiver(self.pusch_transmitter) 

        # Channels between each transmitter and receiver
        self.h_freq = None

        # Processing the SINR
        self.sinr = None
        self.sinr_no = None

    def update_channel(self, num_active_tx, a, tau):
        # Call when changing simulation channel without creating new instance - performance benefits with jit compilation.
        self.num_tx = num_active_tx
        self.h_freq = tf.stack([cir_to_ofdm_channel(self.frequencies, a[:,i:i+1,:,j:j+1,:,:,:], tau[:,i:i+1,j:j+1,:], normalize=True) for j in range(self.num_tx) for i in range(self.num_rx)], axis=0)


    def update_sinr(self, sinr):
        # Call when changing simulation channel without creating new instance - performance benefits with jit compilation.
        M = np.array(self.pusch_config.tb.num_bits_per_symbol)
        R = np.array(self.pusch_config.tb.target_coderate)
        ebno = sinr - (10 * np.log10(R * M)) # SINR to EbNo conversion
        self.sinr = sinr
        # Noise variance dependent on the SINR, this enables handling interference
        self.sinr_no = tf.clip_by_value(tf.convert_to_tensor([ebnodb2no(item,
            self.pusch_transmitter._num_bits_per_symbol, 
            self.pusch_transmitter._target_coderate, 
            self.pusch_transmitter.resource_grid) for item in ebno]), 0, 100) # clipped to arbitarily high value for when there is no signal

    @tf.function(jit_compile=True, reduce_retracing=True)
    def iterate(self, ins):
        h, noise = ins
        y = self.channel([self.x, h, noise]) # noise is due to the physical channel effects and noise
        b_hat = self.pusch_receiver([y, noise]) # noise if used for decoding
        bler = compute_bler(self.b, b_hat)
        return bler

    # Do not use @tf.function as attributes will not update
    def call(self, block_size):
        self.x, self.b = self.pusch_transmitter(block_size)  
        bler_per_link = tf.map_fn(self.iterate, elems=(self.h_freq, self.sinr_no), fn_output_signature=tf.float64)
 
        return tf.reshape(bler_per_link, (self.num_tx, self.num_rx)), tf.reshape(self.sinr, (self.num_tx, self.num_rx))

